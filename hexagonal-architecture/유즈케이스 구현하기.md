## 유스케이스를 어떻게 구현할까

- 도메인 계층을 모두가 의존하기에, 도메인 엔티티 중심으로 유즈케이스를 구현

## What UseCase Do

1. Input
    - Incoming Adapter
        - 입력 유효성 검증 : 유즈케이스는 도메인 로직에만 신경 써야만 한다, 이 부분은 어댑터가 처리
2. Validate Business Rule
    - UseCase가 처리, Domain Model 과 이 책임을 공유한다
3. Update Model
    - Input을 이용한, 모델의 상태 변경
    - 변경된 상태 기반으로 아웃고잉 어댑터(영속성 어댑터)를 통해 구현된 포트로 이 상태를 전달하여 저장
4. Output Result
    - 아웃고잉 어댑터의 결과값을 변환 및 반환

---

### 실무에서의 UseCase 개발

1. 어댑터에서 입력값 검증을 처리한다고 생각해보자
    - 모든 어댑터에서 같은 검증을 구현해야한다
    - 실수 가능, 모두 동일하게 검증이 일어난다는 보장이 없음 (믿을 수 없음)
2. 어플리케이션(Domain 계층) 에서 유효성 검증이 일어나야한다
    - Command / Query 객체에서 수행하도록 하자
    - Bean Validation 을 통해 검증, 사실상 유즈케이스를 보호하기 위한 오류 방지 계층을 만든다

--- 

### 생성자, Command/Query 객체 유효성 검증

- 초기화 과정에서, 유효성 검증시, 완전한 객체 생성 가능
- 파라미터가 길어진다 ~> 빌더 도입?
    - 문제 : 빌더 호출 코드에서 새로운 필드 추가하는 것을 잊을 수 있음 ~> 불완전한 불변 객체 생성
    - 생성자 사용한다면, 컴파일러가 잡아준다, IDE

---

### 유즈케이스마다 다른 입력 모델

- 불변 command 객체 필드에 대해 Null 을 유효한 상태로 두는 것은 문제가 발생 할 수 있다
- 또한 서로 다른 입력 유효성 검증 로직이 필요하다
- A 유즈케이스에서 null 이어야할 필드가 non-null 로 들어온다면?
    - 유지보수 지옥
- 모든 유즈케이스에 입력 모델을 별개로 만든다면 이것 또한 매핑 비용 발생함 ~> how ?????

---

### 비즈니스 규칙 검증하기

- 비즈니스 규칙 검증 vs 입력 유효성 검증
    - 비즈니스 규칙 검증
        - 도메인 모델의 현재 상태에 접근해야 한다
        - 유즈케이스 맥락 속에서 의미적인 유효성을 검증
    - 입력 유효성 검증
        - @NotNull 과 같은 선언적 구현
        - 구문상의 유효성을 검증

- example
    - 출금 계좌는 초과 출금 되어서는 안된다
        - 출금 계좌 확인
        - 입금 계좌 확인
        - 모델의 현재 상태에 접근해야 함 ~> 비즈니스 규칙 검증
    - 송금 되는 금액은 0보다 커야한다 ~> 입력 유효성 검증

- 간단한 비즈니스 규칙은, DB 쿼리 조회로 가능 (리소스 존재 여부)
- 복잡한 비즈니스 규칙은, 도메인 모델 로드 후, 도메인 모델 안에서 비즈니스 규칙 구현 하는 것이 좋음

---

### 풍부한 도메인 모델 vs 빈약한 도메인 모델

- 풍부한 도메인 모델
  - 모델에서 가능한 많은 도메인 로직이 구현된다, 상태 변경 메서드를 제공하고 유효한 변경인지를 검증한다
- 빈약한 도메인 모델
  - 엔티티 모델은 가볍다 (getter setter 정도)
  - 로직은 유즈케이스 클래스에 구현되어 있다
    - 규칙을 검증하고 엔티티의 상태를 변경하고 아웃고잉 포트에 영속을 요청한다

---

### 유즈케이스마다 다른 출력 모델

- 유즈케이스의 리턴 값은 구체적일수록(=유즈케이스 각각에 fit한 데이터) 좋다
- 같은 return object 를 유즈케이스간 공유하게 된다면, 강결합이 발생한다
  - 출력 모델에 새로운 필드 추가시, 다른 유즈케이스에서도 영향을 받는다
