## 단일 책임 원칙

- 하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다. (?)
- **컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다. (O)**

- 하지만, 변경할 이유라는 것은, 컴포넌트 간의 의존성을 통해 너무 쉽게 전파된다.
- A 컴포넌트는 SRP를 지켜 단일 이유로 변경되지만, A를 의존하는 B의 경우엔 A의 변경이 전파 되므로 함께 바뀌어야한다.

## 의존성 역전 원칙

- 상위 계층이 하위 계층에 비해 변경할 이유가 더 많다
- 계층형 아키텍처에선 영속성 계층의 변화가 도메인 계층의 변화로 이어진다
- 영속성 코드가 변경되어도 도메인 코드까진 변경하고 싶지 않다.
  - How?

### 코드 상의 어떤 의존성이든 그 방향을 바꿀 수(역전 시킬 수) 있다.

- 도메인 계층에 Entity(=Model)와 Repository Interface(=data provider) 를 만들어서 영속 계층과 의존관계를 끊는다.
- 이를 통해, 영속계층과 의존을 끊을 수 있다.

## 클린 아키텍처

- 도메인 코드에 바깥으로 향하는 어떤 의존성(DB/UI)도 없어야 한다
- 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

## 헥사고날 아키텍처

- port / adapter 를 기반으로 구현
- driving adapter (in) : port 는 코어 유즈케이스 클래스에 의해 구현
- driven adapter (out) : port 는 어댑터에 의해 구현

- adapter : core application 과 다른 System 과의 통신/번역
- port / UseCase : application
- domain

---

결론 : 어떤 패턴이든 도메인과 다른 계층을 확실하게 분리만 하자........., 그래야 DDD든 뭐든 한다